/*+**************************************************************************/
/***                                                                      ***/
/***   This file is distributed under a BSD license.                      ***/
/***   See LICENSE.txt for details.                                       ***/
/***                                                                      ***/
/**************************************************************************+*/

header
{
#include "wz4lib/basic_ops.hpp"
}
code
{
#include "wz4frlib/wz4_physx.hpp"
#include "wz4frlib/wz4_demo2nodes.hpp"
}

/****************************************************************************/
/****************************************************************************/

type PhysXTab
{
  name = "PhysX";
  color = 0xFFCCEC82;
  gui = base3d;
  flags = render3d;

  columnheader[0] = "system";
  columnheader[1] = "actor";
  columnheader[2] = "collider";
}

/****************************************************************************/
/****************************************************************************/

type WpxColliderBase
{
  name = "WpxColliderBase";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;

  extern void Show(wObject *obj,wPaintInfo &pi)
  {
    sSetTarget(sTargetPara(pi.ClearFirst ? sST_CLEARALL : 0,pi.BackColor,pi.Spec));

    pi.ClearFirst = sFALSE;
    pi.View->SetTargetCurrent();
    pi.View->SetZoom(pi.Zoom3D);
    pi.View->Prepare();

    Paint(obj,pi);
  }

  extern void Paint(wObject *obj,wPaintInfo &pi)
  {
    if(obj && obj->IsType(WpxColliderBaseType))
    {
      Wz4MtrlType->PrepareView(*pi.View);
      sFrustum fr;
      fr.Init(pi.View->ModelScreen);

      Wz4RenderContext ctx;
      sTargetSpec spec = pi.Spec;
      ctx.Init(0, &spec, &pi);
      sRTMan->ResolutionCheck(this, ctx.ScreenX, ctx.ScreenY);
      ctx.RenderFlags |= pi.Wireframe ? wRF_RenderWire : wRF_RenderMain;
      if (pi.CamOverride)
        ctx.RenderFlags |= wRF_FreeCam;
      ctx.View = *pi.View;
      ctx.Frustum = fr;
      ctx.RenderMode = sRF_TARGET_MAIN;

      sMatrix34 mat;
      mat.Init();

      WpxColliderBase * wpxcol = (WpxColliderBase *) obj;
      wpxcol->ClearMatricesR();
      wpxcol->Transform(mat,0,0);
      wpxcol->Render(ctx,mat);
    }
  }

}

/****************************************************************************/
/****************************************************************************/

type WpxCollider : WpxColliderBase
{
  name = "WpxCollider";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;
}

type WpxColliderAdd : WpxColliderBase
{
  name = "WpxColliderAdd";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;
}

type WpxColliderTransform : WpxColliderBase
{
  name = "WpxColliderTransform";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;
}

type WpxColliderMul : WpxColliderBase
{
  name = "WpxColliderMul";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;
}

/****************************************************************************/
/****************************************************************************/

operator WpxCollider Collider (?Wz4Mesh)
{
  tab = PhysXTab;
  column = 2;
  shortcut = 'c';

  parameter
  {
    group "Shape";
    layout flags GeometryType("box|sphere|plane|hullmesh|mesh");
    if(GeometryType == 0)
    {
      float31 Dimension (0.001..0x10000 step 0.01) = 1;
    }
    if(GeometryType == 1)
    {
      float Radius (0.001..0x10000 step 0.01) = 1;
    }
    group "Transform";
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = 0;
    group "PhysX Material";
    float StaticFriction (0.001..0x10000 step 0.01) = 0.5;
    float DynamicFriction (0.001..0x10000 step 0.01) = 0.5;
    float Restitution (-0x10000..0x10000 step 0.01) = 0.5;
  }
  code
  {
    out->ParaBase = out->Para = *para;
    out->CreateGeometry(in0);
  }
}

/****************************************************************************/

operator WpxColliderAdd ColliderAdd "Add" (*WpxColliderBase)
{
  tab = PhysXTab;
  column = 2;

  parameter
  {
  }
  code
  {
    out->ParaBase = out->Para = *para;
    out->AddCollidersChilds(cmd);
  }
}

/****************************************************************************/

operator WpxColliderTransform ColliderTransform "Transform" (WpxColliderBase)
{
  tab = PhysXTab;
  column = 2;

  parameter
  {
    float31 Scale (-1024..1024 step 0.01) = 1;
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
  }
  code
  {
    out->ParaBase = out->Para = *para;
    out->AddCollidersChilds(cmd);
  }
}

/****************************************************************************/

operator WpxColliderMul ColliderMul "Multiply" (WpxColliderBase)
{
  tab = PhysXTab;
  column = 2;

  parameter
  {
    flags Flags ("-|Center");
    group "Pre-Transform";
    float31 PreScale (-1024..1024 step 0.01) = 1;
    float30 PreRot (-16..16 step 0.01) = 0;
    float31 PreTrans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
    group "Multiply Transform";
    int Count(1..1024) = 2;
    float31 Scale (-1024..1024 step 0.01) = 1;
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
  }
  code
  {
    out->ParaBase = out->Para = *para;
    out->AddCollidersChilds(cmd);
  }
}

/****************************************************************************/
/****************************************************************************/

type WpxActorBase
{
  name = "WpxActorBase";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;

  extern void Show(wObject *obj,wPaintInfo &pi)
  {
    sSetTarget(sTargetPara(pi.ClearFirst ? sST_CLEARALL : 0,pi.BackColor,pi.Spec));

    pi.ClearFirst = sFALSE;
    pi.View->SetTargetCurrent();
    pi.View->SetZoom(pi.Zoom3D);
    pi.View->Prepare();

    Paint(obj,pi);
  }

  extern void Paint(wObject *obj,wPaintInfo &pi)
  {
    if(obj && obj->IsType(WpxActorBaseType))
    {
      Wz4MtrlType->PrepareView(*pi.View);
      sFrustum fr;
      fr.Init(pi.View->ModelScreen);

      Wz4RenderContext ctx;
      sTargetSpec spec = pi.Spec;
      ctx.Init(0, &spec, &pi);
      sRTMan->ResolutionCheck(this, ctx.ScreenX, ctx.ScreenY);
      ctx.RenderFlags |= pi.Wireframe ? wRF_RenderWire : wRF_RenderMain;
      if (pi.CamOverride)
        ctx.RenderFlags |= wRF_FreeCam;
      ctx.View = *pi.View;
      ctx.Frustum = fr;

      if( (ctx.RenderFlags&wRF_RenderWire) == 0)
        ctx.RenderMode = sRF_TARGET_MAIN;
      else
        ctx.RenderMode = sRF_TARGET_WIRE;

      sMatrix34 mat;
      mat.Init();

      WpxActorBase * b = (WpxActorBase *) obj;
      b->ClearMatricesR();
      b->Transform(mat,0,0);
      b->Render(ctx,mat);
    }
  }

}

/****************************************************************************/
/****************************************************************************/

type WpxRigidBody : WpxActorBase
{
  name = "WpxRigidBody";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;
}

type WpxRigidBodyAdd : WpxActorBase
{
  name = "WpxRigidBodyAdd";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;
}

type WpxRigidBodyTransform : WpxActorBase
{
  name = "WpxRigidBodyTransform";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;
}

type WpxRigidBodyMul : WpxActorBase
{
  name = "WpxRigidBodyMul";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;
}

/****************************************************************************/
/****************************************************************************/

operator WpxRigidBody RigidBody (Wz4Render, WpxColliderBase)
{
  tab = PhysXTab;
  column = 1;
  shortcut = 'r';

  parameter
  {
    int Renderpass(-127..127);
    group "Transform";
    float31 Scale (-0x10000..0x10000 step 0.01) = 1;
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = 0;

    layout flags ActorType("static|dynamic") = 0;
  }
  code
  {
    WpxRigidBodyNodeDynamic * node = new WpxRigidBodyNodeDynamic();
    node->ParaBase = out->ParaBase = out->Para = *para;

    // add colliders
    out->AddRootCollider(in1);

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass, 0, 1);
  }
}

/****************************************************************************/

operator WpxRigidBodyAdd RigidBodyAdd "Add" (*WpxActorBase)
{
  tab = PhysXTab;
  column = 1;

  parameter
  {
    int Renderpass(-127..127);
  }
  code
  {
    WpxRigidBodyNode * node = new WpxRigidBodyNode();
    out->ParaBase = out->Para = *para;

    out->AddActorsChilds(cmd);

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass);
  }
}

/****************************************************************************/

operator WpxRigidBodyTransform RigidBodyTransform "Transform" (WpxActorBase)
{
  tab = PhysXTab;
  column = 1;

  parameter
  {
    int Renderpass(-127..127);
    float31 Scale (-1024..1024 step 0.01) = 1;
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
  }
  code
  {
    WpxRigidBodyNodeDynamicTransform * node = new WpxRigidBodyNodeDynamicTransform();
    node->ParaBase = out->ParaBase = out->Para = *para;

    out->AddActorsChilds(cmd);

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass);
  }
}

/****************************************************************************/

operator WpxRigidBodyMul RigidBodyMul "Multiply" (WpxActorBase)
{
  tab = PhysXTab;
  column = 1;

  parameter
  {
    int Renderpass(-127..127);
    flags Flags ("-|Center");
    group "Pre-Transform";
    float31 PreScale (-1024..1024 step 0.01) = 1;
    float30 PreRot (-16..16 step 0.01) = 0;
    float31 PreTrans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
    group "Multiply Transform";
    int Count(1..1024) = 2;
    float31 Scale (-1024..1024 step 0.01) = 1;
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
  }
  code
  {
    WpxRigidBodyNodeDynamicMul * node = new WpxRigidBodyNodeDynamicMul();
    node->ParaBase = out->ParaBase = out->Para = *para;

    out->AddActorsChilds(cmd);

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass);
  }
}

/****************************************************************************/
/****************************************************************************/

operator Wz4Render Physx (*WpxActorBase)
{
  tab = PhysXTab;
  column = 0;
  shortcut = 'x';

  parameter
  {
    action Restart(1);
    int Renderpass(-127..127);
    int NumThreads (0..16) = 1;
    float31 Gravity (-0x10000..0x10000 step 0.001) = { 0.0, -9.8, 0.0 };

    group "Animation Script"; overbox overlabel linenumber lines 5 string Script;
  }
  actions
  {
    if(code==1)
      return 1;
    else
      return 0;
  }
  code
  {
    RNPhysx *node = new RNPhysx();
    node->ParaBase = node->Para = *para;

    if(!node->Init(cmd))
    {
      cmd->SetError(L"Failed to init physx scene");
      return 0;
    }

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass);
  }
}
