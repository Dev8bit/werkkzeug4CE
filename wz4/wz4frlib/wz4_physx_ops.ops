/*+**************************************************************************/
/***                                                                      ***/
/***   This file is distributed under a BSD license.                      ***/
/***   See LICENSE.txt for details.                                       ***/
/***                                                                      ***/
/**************************************************************************+*/

header
{
#include "wz4lib/basic_ops.hpp"
}
code
{
#include "wz4frlib/wz4_physx.hpp"
#include "wz4frlib/wz4_demo2nodes.hpp"
}

/****************************************************************************/
/****************************************************************************/

type PhysXTab
{
  name = "PhysX";
  color = 0xFFCCEC82;
  gui = base3d;
  flags = render3d;

  columnheader[0] = "system";
  columnheader[1] = "actor";
  columnheader[2] = "collider";
}

/****************************************************************************/
/****************************************************************************/

type WpxColliderBase
{
  name = "WpxColliderBase";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;

  extern void Show(wObject *obj,wPaintInfo &pi)
  {
    sSetTarget(sTargetPara(pi.ClearFirst ? sST_CLEARALL : 0,pi.BackColor,pi.Spec));

    pi.ClearFirst = sFALSE;
    pi.View->SetTargetCurrent();
    pi.View->SetZoom(pi.Zoom3D);
    pi.View->Prepare();

    Paint(obj,pi);
  }

  extern void Paint(wObject *obj,wPaintInfo &pi)
  {
    if(obj && obj->IsType(WpxColliderBaseType))
    {
      Wz4MtrlType->PrepareView(*pi.View);
      sFrustum fr;
      fr.Init(pi.View->ModelScreen);

      Wz4RenderContext ctx;
      sTargetSpec spec = pi.Spec;
      ctx.Init(0, &spec, &pi);
      sRTMan->ResolutionCheck(this, ctx.ScreenX, ctx.ScreenY);
      ctx.RenderFlags |= pi.Wireframe ? wRF_RenderWire : wRF_RenderMain;
      if (pi.CamOverride)
        ctx.RenderFlags |= wRF_FreeCam;
      ctx.View = *pi.View;
      ctx.Frustum = fr;
      ctx.RenderMode = sRF_TARGET_MAIN;

      sMatrix34 mat;
      mat.Init();

      WpxColliderBase * wpxcol = (WpxColliderBase *) obj;
      wpxcol->ClearMatricesR();
      wpxcol->Transform(mat,0);
      wpxcol->Render(ctx,mat);
    }
  }

}

/****************************************************************************/
/****************************************************************************/

type WpxCollider : WpxColliderBase
{
  name = "WpxCollider";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;
}

type WpxColliderAdd : WpxColliderBase
{
  name = "WpxColliderAdd";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;
}

type WpxColliderTransform : WpxColliderBase
{
  name = "WpxColliderTransform";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;
}

type WpxColliderMul : WpxColliderBase
{
  name = "WpxColliderMul";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;
}

/****************************************************************************/
/****************************************************************************/

operator WpxCollider Collider (?Wz4Mesh)
{
  tab = PhysXTab;
  column = 2;
  shortcut = 'c';

  parameter
  {
    group "Shape";
    layout flags GeometryType("box|sphere|plane|hullmesh|mesh");
    if(GeometryType == 0 || GeometryType == 2)
    {
      float31 Dimension (0.001..0x10000 step 0.01) = 1;
    }
    if(GeometryType == 1)
    {
      float Radius (0.001..0x10000 step 0.01) = 1;
    }
    group "Transform";
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = 0;
    group "Properties";
    float Density (0.0001..0x10000 step 0.01) = 1.0;
    group "PhysX Material";
    float StaticFriction (0.001..0x10000 step 0.01) = 0.5;
    float DynamicFriction (0.001..0x10000 step 0.01) = 0.5;
    float Restitution (-0x10000..0x10000 step 0.01) = 0.5;
  }
  code
  {
    out->ParaBase = out->Para = *para;

    // if hull or mesh type, in0 is required
    if((para->GeometryType == 3 || para->GeometryType == 4) && !in0)
    {
      cmd->SetError(L"Required input is missing");
      return 0;
    }

    // build collider geometry for collider mesh preview
    if(!out->CreateGeometry(in0))
    {
      if(para->GeometryType == 3)
        cmd->SetError(L"Failed to create hull from mesh, try to change mesh geometry (limited to 256 polygons)");
      else
        cmd->SetError(L"Failed to create collider");
      return 0;
    }
  }
}

/****************************************************************************/

operator WpxColliderAdd ColliderAdd "Add" (*WpxColliderBase)
{
  tab = PhysXTab;
  column = 2;

  parameter
  {
  }
  code
  {
    out->ParaBase = out->Para = *para;
    out->AddCollidersChilds(cmd);
  }
}

/****************************************************************************/

operator WpxColliderTransform ColliderTransform "Transform" (WpxColliderBase)
{
  tab = PhysXTab;
  column = 2;

  parameter
  {
    if(0) float31 Scale (-1024..1024 step 0.01) = 1;  // for exchange scene
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
  }
  code
  {
    out->ParaBase = out->Para = *para;
    out->AddCollidersChilds(cmd);
  }
}

/****************************************************************************/

operator WpxColliderMul ColliderMul "Multiply" (WpxColliderBase)
{
  tab = PhysXTab;
  column = 2;

  parameter
  {
    if(0) int Renderpass(-127..127);    // for exchange scene
    flags Flags ("-|Center");
    group "Pre-Transform";
    if(0) float31 PreScale (-1024..1024 step 0.01) = 1; // for exchange scene
    float30 PreRot (-16..16 step 0.01) = 0;
    float31 PreTrans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
    group "Multiply Transform";
    int Count(1..1024) = 2;
    if(0) float31 Scale (-1024..1024 step 0.01) = 1;  // for exchange scene
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
  }
  code
  {
    out->ParaBase = out->Para = *para;
    out->AddCollidersChilds(cmd);
  }
}

/****************************************************************************/
/****************************************************************************/

type WpxActorBase
{
  name = "WpxActorBase";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;

  extern void Show(wObject *obj,wPaintInfo &pi)
  {
    sSetTarget(sTargetPara(pi.ClearFirst ? sST_CLEARALL : 0,pi.BackColor,pi.Spec));

    pi.ClearFirst = sFALSE;
    pi.View->SetTargetCurrent();
    pi.View->SetZoom(pi.Zoom3D);
    pi.View->Prepare();

    Paint(obj,pi);
  }

  extern void Paint(wObject *obj,wPaintInfo &pi)
  {
    if(obj && obj->IsType(WpxActorBaseType))
    {
      Wz4MtrlType->PrepareView(*pi.View);
      sFrustum fr;
      fr.Init(pi.View->ModelScreen);

      Wz4RenderContext ctx;
      sTargetSpec spec = pi.Spec;
      ctx.Init(0, &spec, &pi);
      sRTMan->ResolutionCheck(this, ctx.ScreenX, ctx.ScreenY);
      ctx.RenderFlags |= pi.Wireframe ? wRF_RenderWire : wRF_RenderMain;
      if (pi.CamOverride)
        ctx.RenderFlags |= wRF_FreeCam;
      ctx.View = *pi.View;
      ctx.Frustum = fr;

      if( (ctx.RenderFlags&wRF_RenderWire) == 0)
        ctx.RenderMode = sRF_TARGET_MAIN;
      else
        ctx.RenderMode = sRF_TARGET_WIRE;

      sMatrix34 mat;
      mat.Init();

      WpxActorBase * b = (WpxActorBase *) obj;
      b->ClearMatricesR();
      b->Transform(mat,0);
      b->Render(ctx,mat);
    }
  }

}

/****************************************************************************/
/****************************************************************************/

type WpxRigidBody : WpxActorBase
{
  name = "WpxRigidBody";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;
}

type WpxRigidBodyAdd : WpxActorBase
{
  name = "WpxRigidBodyAdd";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;
}

type WpxRigidBodyTransform : WpxActorBase
{
  name = "WpxRigidBodyTransform";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;
}

type WpxRigidBodyMul : WpxActorBase
{
  name = "WpxRigidBodyMul";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;
}

type WpxRigidBodyDebris : WpxActorBase
{
  name = "WpxRigidBodyDebris";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFF9CCC52;
}

/****************************************************************************/
/****************************************************************************/

operator WpxRigidBody RigidBody (Wz4Render, WpxColliderBase)
{
  tab = PhysXTab;
  column = 1;
  shortcut = 'r';

  parameter
  {
    int Renderpass(-127..127);

    group "Transform";
    //anim float31 Scale (-0x10000..0x10000 step 0.01) = 1;
    anim float30 Rot (-16..16 step 0.01) = 0;
    anim float31 Trans (-0x10000..0x10000 step 0.01) = 0;

    group "Actor type";
    layout flags ActorType("static|dynamic|kinematic") = 0;

    if(ActorType == 1)
    {
      group "Mass And Inertia";
      layout flags MassAndInertia("colliders densities|-") = 0;
      if(MassAndInertia == 1)
      {
        float31 CenterOfMass (-0x10000..0x10000 step 0.01) = 0;
        float Mass(0.001..0x10000 step 0.01) = 1.0;
      }

      group "Initial Velocity";
      float31 LinearVelocity (-0x10000..0x10000 step 0.01) = 0;
      float31 AngularVelocity (-0x10000..0x10000 step 0.01) = 0;
      float MaxAngularVelocity (0..0x10000 step 0.01) = 7;

      group "Forces";
      float SleepThreshold (0..0x10000 step 0.01) = 0.05;
      anim layout flags Sleep ("no|yes") = 0;
      anim layout flags Gravity("off|on") = 1;
      anim float LinearDamping (0..0x10000 step 0.001) = 0.0;
      anim float AngularDamping (0..0x10000 step 0.001) = 0.05;

      anim layout flags ForceMode "Force" ("simple|impulse|velocity|acceleration|-") = 4;
      if(ForceMode != 4)
        anim nolabel float31 Force (-0x10000..0x10000 step 0.001) = 0;

      anim layout flags TorqueMode "Torque" ("simple|impulse|velocity|acceleration|-") = 4;
      if(TorqueMode != 4)
        anim nolabel float31 Torque (-0x10000..0x10000 step 0.001) = 0;

      layout flags TimeFlag("once|loop") = 0;
    }

    group "Animation Script"; overbox overlabel linenumber lines 5 string Script;
  }
  code
  {
    WpxRigidBodyNodeBase * node = 0;
    if(para->ActorType == 0)
      node = new WpxRigidBodyNodeStatic();
    if(para->ActorType == 1)
      node = new WpxRigidBodyNodeDynamic();
    if(para->ActorType == 2)
      node = new WpxRigidBodyNodeKinematic();

    if(node==0)
    {
      cmd->SetError(L"Fatal error (unknown actor type)...");
      return 0;
    }

    node->ParaBase = out->ParaBase = out->Para = *para;

    node->Init();

    // add colliders
    out->AddRootCollider(in1);

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass, 0, 1);
  }
  handles
  {
    // paint cross Center of mass
    if(para->MassAndInertia == 1)
    {
      sMatrix34 mat;
      sSRT srt;
      srt.Translate = para->Trans;
      srt.Rotate = para->Rot;
      srt.MakeMatrix(mat);

      sVector31 v[6],p;
      bool zoff = true;
      sF32 s = 0.2f;
      sVector31 o = para->CenterOfMass;

      // cross
      p.Init(o.x-s, o.y,   o.z);    v[0] = p*mat;
      p.Init(o.x+s, o.y,   o.z);    v[1] = p*mat;
      p.Init(o.x,   o.y-s, o.z);    v[2] = p*mat;
      p.Init(o.x,   o.y+s, o.z);    v[3] = p*mat;
      p.Init(o.x,   o.y,   o.z-s);  v[4] = p*mat;
      p.Init(o.x,   o.y,   o.z+s);  v[5] = p*mat;
      pi.Line3D(v[0],v[1],0,zoff);
      pi.Line3D(v[2],v[3],0,zoff);
      pi.Line3D(v[4],v[5],0,zoff);
    }
  }
}

/****************************************************************************/

operator WpxRigidBodyDebris RigidBodyDebris "Debris" (Wz4Render)
{
  tab = PhysXTab;
  column = 1;

  parameter
  {
    int Renderpass(-127..127);
    anim int EnvNum(0..15) = 0;

    group "Transform";
    //anim float31 Scale (-0x10000..0x10000 step 0.01) = 1;
    anim float30 Rot (-16..16 step 0.01) = 0;
    anim float31 Trans (-0x10000..0x10000 step 0.01) = 0;

    group "Collider Properties";
    float Density (0.0001..0x10000 step 0.01) = 1.0;

    group "PhysX Material";
    float StaticFriction (0.001..0x10000 step 0.01) = 0.5;
    float DynamicFriction (0.001..0x10000 step 0.01) = 0.5;
    float Restitution (-0x10000..0x10000 step 0.01) = 0.5;

    group "Actor type";
    layout flags ActorType("static|dynamic") = 0;

    if(ActorType == 1)
    {
      group "Mass And Inertia";
      layout flags MassAndInertia("colliders densities|-") = 0;
      if(MassAndInertia == 1)
      {
        float31 CenterOfMass (-0x10000..0x10000 step 0.01) = 0;
        float Mass(0.001..0x10000 step 0.01) = 1.0;
      }

      group "Initial Velocity";
      float31 LinearVelocity (-0x10000..0x10000 step 0.01) = 0;
      float31 AngularVelocity (-0x10000..0x10000 step 0.01) = 0;
      float MaxAngularVelocity (0..0x10000 step 0.01) = 7;

      group "Forces";
      float SleepThreshold (0..0x10000 step 0.01) = 0.05;
      anim layout flags Sleep ("no|yes") = 0;
      anim layout flags Gravity("off|on") = 1;
      anim float LinearDamping (0..0x10000 step 0.001) = 0.0;
      anim float AngularDamping (0..0x10000 step 0.001) = 0.05;

      anim layout flags ForceMode "Force" ("simple|impulse|velocity|acceleration|-") = 4;
      if(ForceMode != 4)
        anim nolabel float31 Force (-0x10000..0x10000 step 0.001) = 0;

      anim layout flags TorqueMode "Torque" ("simple|impulse|velocity|acceleration|-") = 4;
      if(TorqueMode != 4)
        anim nolabel float31 Torque (-0x10000..0x10000 step 0.001) = 0;

      layout flags TimeFlag("once|loop") = 0;
    }

    group "Animation Script"; overbox overlabel linenumber lines 5 string Script;
  }
  code
  {
    WpxRigidBodyNodeDebris * node = new WpxRigidBodyNodeDebris();
    node->ParaBase = out->ParaBase = out->Para = *para;

    sInt errcode = out->GetChunkedMesh(in0);
    if(errcode == 1)
    {
      cmd->SetError(L"Need a mesh as input...");
      return 0;
    }
    else if(errcode == 2)
    {
      cmd->SetError(L"Mesh is not chunked...");
      return 0;
    }

    node->ChunkedMeshPtr = out->ChunkedMesh;

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass);
  }
}

/****************************************************************************/

operator WpxRigidBodyAdd RigidBodyAdd "Add" (*WpxActorBase)
{
  tab = PhysXTab;
  column = 1;

  parameter
  {
    int Renderpass(-127..127);
  }
  code
  {
    WpxRigidBodyNodeBase * node = new WpxRigidBodyNodeBase();
    out->ParaBase = out->Para = *para;

    out->AddActorsChilds(cmd);

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass);
  }
}

/****************************************************************************/

operator WpxRigidBodyTransform RigidBodyTransform "Transform" (WpxActorBase)
{
  tab = PhysXTab;
  column = 1;

  parameter
  {
    int Renderpass(-127..127);
    //float31 Scale (-1024..1024 step 0.01) = 1;
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
  }
  code
  {
    WpxRigidBodyNodeBase * node = new WpxRigidBodyNodeBase();
    out->ParaBase = out->Para = *para;

    out->AddActorsChilds(cmd);

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass);
  }
}

/****************************************************************************/

operator WpxRigidBodyMul RigidBodyMul "Multiply" (WpxActorBase)
{
  tab = PhysXTab;
  column = 1;

  parameter
  {
    int Renderpass(-127..127);
    flags Flags ("-|Center");
    group "Pre-Transform";
    //float31 PreScale (-1024..1024 step 0.01) = 1;
    float30 PreRot (-16..16 step 0.01) = 0;
    float31 PreTrans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
    group "Multiply Transform";
    int Count(1..1024) = 2;
    //float31 Scale (-1024..1024 step 0.01) = 1;
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;
  }
  code
  {
    WpxRigidBodyNodeBase * node = new WpxRigidBodyNodeBase();
    out->ParaBase = out->Para = *para;

    out->AddActorsChilds(cmd);

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass);
  }
}

/****************************************************************************/
/****************************************************************************/

operator Wz4Render Physx (*WpxActorBase)
{
  tab = PhysXTab;
  column = 0;
  shortcut = 'x';

  parameter
  {
    action Restart(1);
    int Renderpass(-127..127);
    int NumThreads (0..16) = 1;
    anim flags Enable ("-|Enable") = 1;
    float31 Gravity (-0x10000..0x10000 step 0.001) = { 0.0, -9.8, 0.0 };

    group "Scene flags";
    layout flags Desc ("-|pcm:*2-|one dir friction:*4-|two dir friction");

    group "Simulation loop";
    anim int TimeStep (10..10000) = 60;
    layout flags WaitFetchResults ("no|yes") = 1;
    layout flags TimeSync ("-|yes") = 1;
    if(TimeSync==1)
    {
      layout flags SyncMethod ("method1|method2") = 0;
      if(SyncMethod==1)
        anim float DeltaLimit (-1000..1000 step 0.001) = 0.03;
      anim float DeltaScale (-1000..1000 step 0.001) = 0.001;
    }


    group "Pre-Simulation";
    layout flags PreDelay ("-|enabled") = 0;
    if(PreDelay == 1)
      int PreDelayCycles (0..0x100000 step 10) = 20;
    layout flags PreSimulation ("-|enabled") = 0;
    if(PreSimulation == 1)
      int SimulationCycles (0..0x100000 step 10) = 20;

    group "Animation Script"; overbox overlabel linenumber lines 5 string Script;
  }
  actions
  {
    if(code==1)
      return 1;
    else
      return 0;
  }
  code
  {
    RNPhysx *node = new RNPhysx();
    node->ParaBase = node->Para = *para;

    if(!node->Init(cmd))
    {
      cmd->SetError(L"Failed to init physx scene");
      return 0;
    }

    out->RootNode = node;
    out->AddChilds(cmd, para->Renderpass);
  }
}
