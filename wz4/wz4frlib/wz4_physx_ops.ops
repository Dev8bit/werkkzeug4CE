/*+**************************************************************************/
/***                                                                      ***/
/***   This file is distributed under a BSD license.                      ***/
/***   See LICENSE.txt for details.                                       ***/
/***                                                                      ***/
/**************************************************************************+*/

header
{
#include "wz4lib/basic_ops.hpp"
}
code
{
#include "wz4frlib/wz4_physx.hpp"
#include "wz4frlib/wz4_demo2nodes.hpp"
}

/****************************************************************************/
/****************************************************************************/

type PhysXTab
{
  name = "PhysX";
  color = 0xFFCCEC82;
  gui = base3d;  
  flags = render3d;

  columnheader[0] = "system";
  columnheader[1] = "actor";
  columnheader[2] = "collider";
}

/****************************************************************************/

type WpxCollider
{
  name = "WpxCollider";
  gui = base3d;
  flags = render3d|notab;
  color = 0xFFCCEC82;
   
  extern void Show(wObject *obj,wPaintInfo &pi)
  {
    sSetTarget(sTargetPara(pi.ClearFirst ? sST_CLEARALL : 0,pi.BackColor,pi.Spec));
    
    pi.ClearFirst = sFALSE;
    pi.View->SetTargetCurrent();
    pi.View->SetZoom(pi.Zoom3D);
    pi.View->Prepare();

    sMatrix34 mat;
    mat.Init();
    Paint(obj,pi,&mat,1);   
  }
    
  extern void Paint(wObject *obj,wPaintInfo &pi,sMatrix34 *mat,sInt matcount)
  {
    if(obj && obj->IsType(WpxColliderType))
    {      
      Wz4MtrlType->PrepareView(*pi.View);
      sFrustum fr; 
      fr.Init(pi.View->ModelScreen);

      WpxCollider * wpxcol = (WpxCollider *) obj;
      
      // render all colliders shapes
      sColliderObj * col;
      sFORALL(*wpxcol->ColliderDataPtr, col)
      {
        col->ShapePtr->Render(sRF_TARGET_MAIN,0,&sMatrix34CM(*mat),0,fr);
        col->ShapePtr->Render(sRF_TARGET_WIRE,0,&sMatrix34CM(*mat),0,fr);
      }
    }
  }
}

/****************************************************************************/

type WpxActor
{
  name = "WpxActor";
  color = 0xFF9CCC52;
  flags = render3d|notab;
  gui = base3d;

  extern void Show(wObject *obj,wPaintInfo &pi)
  {
    sSetTarget(sTargetPara(pi.ClearFirst ? sST_CLEARALL : 0,pi.BackColor,pi.Spec));
    
    pi.ClearFirst = sFALSE;
    pi.View->SetTargetCurrent();
    pi.View->SetZoom(pi.Zoom3D);
    pi.View->Prepare();

    sMatrix34 mat;
    mat.Init();    

    if(!pi.Wireframe)
      Paint(obj,pi,&mat,1);
    else
      Wireframe(obj,pi,mat);
  }

  extern void Paint(wObject *obj,wPaintInfo &pi,sMatrix34 *mat,sInt matcount)
  {
    if(obj && obj->IsType(WpxActorType))
    {
      Wz4MtrlType->PrepareView(*pi.View);
      sFrustum fr; 
      fr.Init(pi.View->ModelScreen);
      
      WpxActor * wpxactor = (WpxActor*)obj;     

      sActorObj * actorObj;
      sFORALL(*wpxactor->ActorDataPtr, actorObj)
      {
        // render actor mesh
        if(actorObj->MeshPtr)
          actorObj->MeshPtr->Render(sRF_TARGET_MAIN,0,&sMatrix34CM(*mat**actorObj->GlobalMatrixPtr),0,fr);

        // render all joint pose
        for(int i=0; i<actorObj->JointsMatrixArrayPtr->GetCount(); i++) 
          actorObj->JointMeshPtr->Render(sRF_TARGET_MAIN,0,&sMatrix34CM(*mat * *actorObj->JointsMatrixArrayPtr[0][i]),0,fr);

        // render all colliders shapes
        sColliderObj * col = actorObj->ColliderDataPtr->GetData();        
        for(int i=0; i<actorObj->ColliderDataPtr->GetCount(); i++)  
        {          
          col->ShapePtr->Render(sRF_TARGET_MAIN,0,&sMatrix34CM(*mat * *actorObj->GlobalMatrixPtr),0,fr);
          col->ShapePtr->Render(sRF_TARGET_WIRE,0,&sMatrix34CM(*mat * *actorObj->GlobalMatrixPtr),0,fr);
          col++;
        }
      }
    }
  }

  extern void Wireframe(wObject *obj,wPaintInfo &pi,sMatrix34 &mat)
  {
    if(obj && obj->IsType(WpxActorType))
    {
      Wz4MtrlType->PrepareView(*pi.View);
      sFrustum fr; 
      fr.Init(pi.View->ModelScreen);
      
      WpxActor * wpxactor = (WpxActor*)obj;


      sActorObj * actorObj;
      sFORALL(*wpxactor->ActorDataPtr, actorObj)
      {
        // render mesh
        if(actorObj->MeshPtr)
          actorObj->MeshPtr->Render(sRF_TARGET_WIRE,0,&sMatrix34CM(mat**actorObj->GlobalMatrixPtr),0,fr);

        // render all joint pose
        for(int i=0; i<actorObj->JointsMatrixArrayPtr->GetCount(); i++) 
          actorObj->JointMeshPtr->Render(sRF_TARGET_WIRE,0,&sMatrix34CM(mat * *actorObj->JointsMatrixArrayPtr[0][i]),0,fr);

        // render all colliders shapes
        sColliderObj * col = actorObj->ColliderDataPtr->GetData();        
        for(int i=0; i<actorObj->ColliderDataPtr->GetCount(); i++)  
        {          
          col->ShapePtr->Render(sRF_TARGET_WIRE,0,&sMatrix34CM(mat * *actorObj->GlobalMatrixPtr),0,fr);
          col++;
        }
      }       
    }
  }
}

/****************************************************************************/
/****************************************************************************/

operator WpxCollider ShapeCollider "Collider" (?Wz4Mesh)
{
  tab = PhysXTab;
  column = 2; 
  shortcut = 'c';

  parameter
  {
    group "Shape";
    layout flags GeometryType("box|sphere|plane|hullmesh|mesh");
    if(GeometryType == 0)
    {
      float31 Dimension (0.001..0x10000 step 0.01) = 1;
    }
    if(GeometryType == 1)
    {
      float Radius (0.001..0x10000 step 0.01) = 1;
    }   

    group "Transform";
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = 0;

    group "Properties";
    float Density (0.0001..0x10000 step 0.01) = 1.0;

    group "PhysX Material";
    float StaticFriction (0.001..0x10000 step 0.01) = 0.5;
    float DynamicFriction (0.001..0x10000 step 0.01) = 0.5;
    float Restitution (-0x10000..0x10000 step 0.01) = 0.5;
  }
  code
  {    
    PXShapeCollider *node = new PXShapeCollider();
    node->ParaBase = node->Para = *para;

    out->RootNode = node;

    if((para->GeometryType == 3 || para->GeometryType == 4) && !in0)
    {
      cmd->SetError(L"Required input is missing");
      return 0;
    }

    node->Init(in0);

    if(!node->ShapeMesh)
    {
      if(para->GeometryType == 3)
      {
        cmd->SetError(L"Failed to create hull from mesh, try to change mesh geometry");
      }
      else
      {
        cmd->SetError(L"Failed to create collider");
      }      
      return 0;
    }
    else
    {
      out->ColliderDataPtr = &node->ColliderData;
    }
  } 
}

/****************************************************************************/

operator WpxCollider ShapeAdd "Add" (*WpxCollider)
{
  tab = PhysXTab;
  column = 2;
  shortcut = 'A';

  parameter
  {
  }
  code
  {
    PXShapeAdd *node = new PXShapeAdd();
    node->ParaBase = node->Para = *para;

    for(sInt i=0;i<cmd->InputCount;i++)
    {
      WpxCollider* col = cmd->GetInput<WpxCollider*>(i);
      node->AddCollider(col);  
    }
    
    out->ColliderDataPtr = &node->ColliderData;
    out->RootNode = node;
  }
}


/****************************************************************************/

operator WpxActor RigidBody (Wz4Render, WpxCollider, ?Wz4Render)//?Wz4Mesh)
{
  tab = PhysXTab;
  column = 1;
  shortcut = 'r';

  parameter
  {
    int Renderpass(-127..127);
    anim float30 Rot (-16..16 step 0.01) = 0;
    anim float31 Trans (-0x10000..0x10000 step 0.01) = 0;
    layout flags ActorType("static|dynamic") = 0;
    if(ActorType == 1)
      layout flags DynamicType("-|kinematic") = 0;    
    group "Actor Builder";
    int ActorID(-1..0x10000000) = -1;
    layout flags BuildMode("mesh|vertices") = 0;
    if(BuildMode == 1)
    {
      float Random(0..1 step 0.01) = 1;      
      int Seed(0..255) = 1;
      float30 RotVertices "Rot" (-16..16 step 0.01) = 0;
    }    
    if(ActorType == 1 && DynamicType == 0)
    {      
      group "Mass And Inertia";
      layout flags MassAndInertia("colliders densities|-") = 0;
      if(MassAndInertia == 1)
      {        
        float31 CenterOfMass (-0x10000..0x10000 step 0.01) = 0;        
        float Mass(0.001..0x10000 step 0.01) = 1.0;
      }

      group "Initial Velocity";
      float31 LinearVelocity (-0x10000..0x10000 step 0.01) = 0;      
      float31 AngularVelocity (-0x10000..0x10000 step 0.01) = 0;
      float MaxAngularVelocity (0..0x10000 step 0.01) = 7;

      group "Forces";
      float SleepThreshold (0..0x10000 step 0.01) = 0.05;
      anim layout flags Sleep ("no|yes") = 0;      
      anim layout flags Gravity("off|on") = 1;
      anim float LinearDamping (0..0x10000 step 0.001) = 0.0;
      anim float AngularDamping (0..0x10000 step 0.001) = 0.05;
          
      anim layout flags ForceMode "Force" ("simple|impulse|velocity|acceleration|-") = 4;
      if(ForceMode != 4)
        anim nolabel float31 Force (-0x10000..0x10000 step 0.001) = 0;

      anim layout flags TorqueMode "Torque" ("simple|impulse|velocity|acceleration|-") = 4;
      if(TorqueMode != 4)
        anim nolabel float31 Torque (-0x10000..0x10000 step 0.001) = 0;

      layout flags TimeFlag("once|loop") = 0;
    }

    group "Animation Script"; overbox overlabel linenumber lines 5 string Script;
    
    group "Joint Fixation Poses";
    array
    {
      float30 Rot (-16..16 step 0.01) = 0;
      float31 Trans (-0x10000..0x10000 step 0.01) = { 0,0,0 };
    }
  }
  code
  {
    PXRigidMesh *node = new PXRigidMesh();
    node->ParaBase = node->Para = *para;

    if(para->BuildMode == 1  && in2 == 0)
    {
      cmd->SetError(L"Missing input...");
      return 0;
    }

    Wz4Mesh * mesh = 0;

    // if in0 is not a RenderMesh (so a Wz4Mesh) we can add the Wz4Mesh for visualisation purposes
    if(!sCmpString(in0->RootNode->Op->Class->Name.Get(), L"RenderMesh"))
    {
        RNRenderMesh * rm = static_cast<RNRenderMesh*>(in0->RootNode);
        if(rm)
        {
          mesh = rm->Mesh;
        }
    }

    if(para->BuildMode == 0)
    {
      node->BuildRigidBodyFromMesh(in1, mesh);
    }
    else
    {
      node->BuildRigidBodyFromVertices(in1, mesh, static_cast<RNRenderMesh*>(in2->RootNode)->Mesh);
    }

    node->BuildJoints((WpxActorArrayRigidBody *) cmd->Array, cmd->ArrayCount);    
    
    out->ActorDataPtr = &node->ActorData;
    out->RootNode = node;    
    out->AddChilds(cmd, para->Renderpass);
  }
  handles
  {
    // paint cross Center of mass
    if(para->MassAndInertia == 1)
    {    
      sMatrix34 mat;
      sSRT srt;
      srt.Translate = para->Trans;
      srt.Rotate = para->Rot;
      srt.MakeMatrix(mat);
    
      sVector31 v[6],p;
      bool zoff = true;
      sF32 s = 0.2f;
      sVector31 o = para->CenterOfMass;
    
      // cross
      p.Init(o.x-s, o.y,   o.z);    v[0] = p*mat;
      p.Init(o.x+s, o.y,   o.z);    v[1] = p*mat;
      p.Init(o.x,   o.y-s, o.z);    v[2] = p*mat;
      p.Init(o.x,   o.y+s, o.z);    v[3] = p*mat;
      p.Init(o.x,   o.y,   o.z-s);  v[4] = p*mat;
      p.Init(o.x,   o.y,   o.z+s);  v[5] = p*mat;
      pi.Line3D(v[0],v[1],0,zoff);
      pi.Line3D(v[2],v[3],0,zoff);
      pi.Line3D(v[4],v[5],0,zoff);
    }
  }
}

/****************************************************************************/

operator WpxActor ActorAdd "Add" (*WpxActor)
{
  tab = PhysXTab;
  column = 1;
  shortcut = 'a';

  parameter
  {
  }
  code
  {
    PXActorAdd *node = new PXActorAdd();
    node->ParaBase = node->Para = *para;
    out->RootNode = node;

    for(sInt i=0;i<cmd->InputCount;i++)
    {
      WpxActor* act = cmd->GetInput<WpxActor*>(i);
      node->AddActor(act);
    }

    out->ActorDataPtr = &node->ActorData;
    out->AddChilds(cmd, in0->RootNode->Renderpass);
  }
}

/****************************************************************************/

operator WpxActor ActorJoint "Joint" (WpxActor)
{
  tab = PhysXTab;
  column = 1;
  shortcut = 'j';

  parameter
  {  
    // PX_MAX_F32 = 3.4028



    //--------------------------------------------------------------------      
    group "fixed settings";
    layout flags FixedSettings ("default|custom") = 0;
    if(FixedSettings)
    {      
      layout flags FixedProjectionFlag ("-|enabled") = 0;
      if(FixedProjectionFlag)
      { 
        float FixedProjectionLinearTolerance "LinearTolerance" (0..0x1000000 step 1) = 1;
        float FixedProjectionAngularTolerance "AngularTolerance" (0..180 step 1) = 160;
      }
    }


    //--------------------------------------------------------------------      
    group "spherical settings";
    layout flags SphericalSettings ("default|custom") = 0;
    if(SphericalSettings)
    {      
      layout flags LimitConeFlag ("-|enabled") = 0;
      if(LimitConeFlag)
      { 
        float LimitConeYLimitAngle (0..180 step 1) = 90;
        float LimitConeZLimitAngle (0..180 step 1) = 90;
        float LimitConeLimitContactDistance (0..0x1000000 step 1) = 1;
        float SphericalLimitDamping "Damping" (0..0x1000000 step 0.1) = 0;
        float SphericalLimitRestitution "Restitution" (0..1 step 0.01) = 0;
        float SphericalLimitSpring "Spring" (0..0x1000000 step 1) = 0;
      }
      layout flags SphericalProjectionFlag ("-|enabled") = 0;
      if(SphericalProjectionFlag)
      { 
        float SphericalProjectionLinearTolerance "LinearTolerance" (0..0x1000000 step 1) = 1;
      }
    }

    //--------------------------------------------------------------------
    group "revolute settings";
    layout flags RevoluteSettings ("default|custom") = 0;
    if(RevoluteSettings)
    {      
      layout flags RevoluteLimitFlag ("-|enabled") = 0;
      if(RevoluteLimitFlag)
      { 
        float RevoluteUpperLimit (-360..360 step 0.01) = 0;
        float RevoluteLowerLimit (-360..360 step 0.01) = 0;
        float RevoluteLimitContactDistance (0..0x1000000 step 1) = 1;
        float RevoluteLimitDamping "Damping" (0..0x1000000 step 0.1) = 0;
        float RevoluteLimitRestitution "Restitution" (0..1 step 0.01) = 0;
        float RevoluteLimitSpring "Spring" (0..0x1000000 step 1) = 0;
      }
      layout flags RevoluteDriveEnabled ("-|enabled") = 0;
      layout flags RevoluteFreeSpinEnabled ("-|enabled") = 0;      
      float DriveForceLimit (0..0x100000 step 0.01) = 3.4028;
      float DriveGearRatio (0..0x100000 step 0.01) = 1;
      float DriveVelocity (-0x100000..0x100000 step 0.01) = 0;

      layout flags RevoluteProjectionFlag ("-|enabled") = 0;
      if(RevoluteProjectionFlag)
      { 
        float RevoluteProjectionLinearTolerance "LinearTolerance" (0..0x1000000 step 1) = 1;
        float RevoluteProjectionAngularTolerance "AngularTolerance" (0..180 step 1) = 160;
      }
    }

    //--------------------------------------------------------------------
    group "prismatic settings";
    layout flags PrismaticSettings ("default|custom") = 0;
    if(PrismaticSettings)
    {
      layout flags LimitPrismaticFlag ("-|enabled") = 0;
      if(LimitPrismaticFlag)
      { 
        float PrismaticUpperLimit (-194.966..194.966 step 0.01) = 194;
        float PrismaticLowerLimit (-194.966..194.966 step 0.01) = -194;
        float PrismaticLimitContactDistance (0..0x1000000 step 1) = 0.009;
        float PrismaticLimitDamping "Damping" (0..0x1000000 step 0.1) = 0;
        float PrismaticLimitRestitution "Restitution" (0..1 step 0.01) = 0;
        float PrismaticLimitSpring "Spring" (0..0x1000000 step 1) = 0;
      }
      layout flags PrismaticProjectionFlag ("-|enabled") = 0;
      if(PrismaticProjectionFlag)
      { 
        float PrismaticProjectionLinearTolerance "LinearTolerance" (0..0x1000000 step 1) = 1;
        float PrismaticProjectionAngularTolerance "AngularTolerance" (0..180 step 1) = 160;
      }
    }

    //--------------------------------------------------------------------
    group "distance settings";
    layout flags DistanceSettings ("default|custom") = 0;
    if(DistanceSettings)
    {
      layout flags MaxDistanceEnable ("-|enabled") = 0;
      if(MaxDistanceEnable)
      { 
        float DistanceMax (0..0x1000000 step 0.1) = 0;
      }
      layout flags MinDistanceEnable ("-|enabled") = 0;
      if(MinDistanceEnable)
      { 
        float DistanceMin (0..0x1000000 step 0.1) = 0;
        float DistanceTolerance (0..0x1000000 step 0.1) = 0;
      }
      layout flags SpringEnable ("-|enabled") = 0;
      if(SpringEnable)
      { 
        float SpringStrength (0..0x1000000 step 0.1) = 10;
        float SpringDamping (0..0x1000000 step 0.1) = 1;
      }
    }

    //--------------------------------------------------------------------
    group "break settings";
    float BreakForceMax (0..0x1000000 step 100) = 50000;
    float BreakTorqueMax (0..0x1000000 step 100) = 50000;
    
    //--------------------------------------------------------------------
    array
    {
      layout flags ModeA ("single|range") = 0;      
      int ActorA (0..65536 step 1) = 0;
      int CountA (0..65536 step 1) = 1;
      
      layout flags ModeB ("single|range") = 0;
      int ActorB (0..65536 step 1) = 0;
      int CountB (0..65536 step 1) = 1;
         
      int JointA_ID(0..65536 step 1) = 0;
      int JointB_ID(0..65536 step 1) = 0;

      layout flags Type ("fixed|spherical|revolute|prismatic|distance") = 0;

      layout flags Breakable ("-|on") = 0;
      layout flags CollideJoint ("-|on") = 0;
    }
  }
  code
  {
    PXActorJoint *node = new PXActorJoint();
    node->ParaBase = node->Para = *para;
    out->RootNode = node;

    node->Init(in0, (WpxActorArrayActorJoint *) cmd->Array, cmd->ArrayCount);

    out->ActorDataPtr = &node->ActorData;
    out->AddChilds(cmd, in0->RootNode->Renderpass);
  }
}

/****************************************************************************/

operator WpxActor ActorMultiply "Multiply" (WpxActor)
{
  tab = PhysXTab;
  column = 1; 
  shortcut = 'm';

  parameter
  { 
    /*group "Pre-Transform"; 
    //anim float31 PreScale (-1024..1024 step 0.01) = 1;
    float30 PreRot (-16..16 step 0.01) = 0;
    float31 PreTrans (-0x10000..0x10000 step 0.01) = { 0,0,0 } ;*/
    
    group "Transform"; 
    int Count (1..1024) = 2;
    //float31 Scale (-1024..1024 step 0.01) = 1;
    float30 Rot (-16..16 step 0.01) = 0;
    float31 Trans (-0x10000..0x10000 step 0.01) = 0;
  }
  code
  {
    PXActorMultiply *node = new PXActorMultiply();
    node->ParaBase = node->Para = *para;
    out->RootNode = node; 

    PXRigidMesh * act = (PXRigidMesh*)in0->RootNode;
    
    sSRT srt;
    sMatrix34 PreMat;    
    sMatrix34 MulMat;

    srt.Scale = sVector31(1,1,1); 
    srt.Rotate = para->Rot;
    srt.Translate = para->Trans;        
    srt.MakeMatrix(MulMat);
    
    /*srt.Scale = sVector31(1,1,1);
    srt.Rotate = para->PreRot;
    srt.Translate = para->PreTrans;
    srt.MakeMatrix(PreMat);*/

    sInt sum = 0;

    // for each actor
    for(sInt i=0; i<act->ActorData.GetCount(); i++)
    {
      sMatrix34 accu;
      bool firstInstance = true;
      bool multipleInstance = false;
      
      if(act->ActorData[i].InstanceCount > 1)
        multipleInstance = true;

      // multiply actor
      for(sInt x=0; x<para->Count; x++)
      {
        sMatrix34  * mul = new sMatrix34();
        *mul = PreMat * accu * *act->ActorData[i].GlobalMatrixPtr;
        node->MulMatArray.AddTail(mul);
     
        // create a new actor data object
        sActorObj * actorData = new sActorObj(act->ActorData[i]);
        actorData->GlobalMatrixPtr = mul;
        actorData->ActorId += x+sum;

        if(firstInstance)
        {
          if(!multipleInstance)
            actorData->InstanceCount = para->Count;
          else
            actorData->InstanceCount = act->ActorData[i].InstanceCount * para->Count;

          firstInstance = false;
        }        

        // add new actor data
        node->ActorData.AddTail(*actorData);       

        // store new matrix ptr in array for clean deletion
        node->ActorDataArray.AddTail(actorData);

        accu = accu * MulMat;
      }

      sum+=para->Count-1;
    }
        
    // copy kinematic actor list ptr
    node->PtrKinematicActorList = act->PtrKinematicActorList;

    // copy animated actor list ptr
    node->PtrAnimatedActorList = act->PtrAnimatedActorList;

    out->AddChilds(cmd, in0->RootNode->Renderpass);
    out->ActorDataPtr = &node->ActorData;  
  }
}

/****************************************************************************/

operator Wz4Render Physx (*WpxActor)
{
  tab = PhysXTab;
  column = 0;
  shortcut = 'x';

  parameter
  {    
    action Restart(1);
    anim int EnvNum (0..15);
    int Renderpass(-127..127);    
    int NumThreads (0..16) = 1;
    anim flags Enable ("-|Enable") = 1;
    float31 Gravity (-0x10000..0x10000 step 0.001) = { 0.0, -9.8, 0.0 };

    group "Time Control";  
    anim int TimeStep (10..10000) = 60;
    layout flags WaitFetchResults ("no|yes") = 1;    
    layout flags TimeMode ("as fast as possible|time synchro") = 1;
    if(TimeMode == 0)
      anim int TicksPerFrame (1..100000 step 1) = 1;
    if(TimeMode == 1)
      anim float DeltaTime (0.001..1 step 0.001) = 0.006;
    
    group "Animation Script"; overbox overlabel linenumber lines 5 string Script; 
  }
 
 actions
  {
    if(code==1)
      return 1;
    else
      return 0;
  }

  code
  {
    RNPhysx *node = new RNPhysx();
    node->ParaBase = node->Para = *para;
    out->RootNode = node;

    if(node->CreateScene())
    {
      for(sInt i=0;i<cmd->InputCount;i++)
      {
        WpxActor* wa = cmd->GetInput<WpxActor*>(i);
        node->BuildActor(wa);
      }
    }
    
    node->Init();
    node->CreateJoints();

    out->AddChilds(cmd, para->Renderpass);
  }
}

/****************************************************************************/